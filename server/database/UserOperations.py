from datetime import datetime, timedelta
import logging
from database.BASE import BaseDatabaseOperation
from models.OrderItemModel import OrderItem
from aws_utils import generate_presigned_url
from pymongo import UpdateOne

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class UserOperations(BaseDatabaseOperation):

    async def get(self, user_id=None) -> list:
        try:
            query = {} if user_id is None else {"user_id": user_id}
            orders = await self.db.orders.find(query).to_list(length=None)

            if not orders:
                return []

            # Prepare a list of user_ids from the orders to fetch user data in one go
            user_ids = {order["user_id"] for order in orders}
            users = await self.db.users.find(
                {"user_id": {"$in": list(user_ids)}}
            ).to_list(length=None)
            user_dict = {
                user["user_id"]: user for user in users
            }  # Create a dictionary of users by user_id

            # Enrich each order with user data and signed URLs for images
            for order in orders:
                user_data = user_dict.get(order["user_id"], {})
                order["user_info"] = user_data  # Add user info to each order
                if "item" in order:  # Assuming each order has an 'items' key
                    for item in order["item"]:
                        img_id = item["img_id"]
                        thumbnail_img_id = "t_" + img_id
                        item["thumbnail"] = generate_presigned_url(
                            thumbnail_img_id, "thumbnails-cart"
                        )
                        item["img_url"] = generate_presigned_url(
                            img_id, "browse-image-v2"
                        )

            return orders
        except Exception as e:
            logger.error(f"Error retrieving orders with user data: {e}")
            return []

    async def get_v2(self) -> list:
        try:
            start = datetime.now()
            pipeline = [
                {
                    '$project': {
                        '_id': 0,
                        'user_id': 1,
                        'order_id': 1,
                        'item': {
                            '$map': {
                                'input': '$item',
                                'as': 'i',
                                'in': {
                                    'apparel': '$$i.apparel',
                                    'size': '$$i.size',
                                    'color': '$$i.color',
                                    'img_id': '$$i.img_id',
                                    'prompt': '$$i.prompt',
                                    'price': '$$i.price',
                                    'greenmask':'$$i.greenmask',
                                    'thumbnail': {
                                        '$cond': {
                                            'if': { '$or': [
                                                { '$eq': [ '$$i.thumbnail', "false" ] },
                                                { '$eq': [ '$$i.thumbnail', None ] },
                                                { '$eq': [ '$$i.thumbnail', False ] },
                                                { '$eq': [ '$$i.thumbnail', "null" ] }
                                            ] },
                                            'then': 'null',
                                            'else': '$$i.thumbnail'
                                        }
                                    },
                                    'toggled': {
                                        '$cond': {
                                            'if': {
                                                        '$or': [
                                                            {'$eq': ['$$i.toggled', False]},
                                                            {'$eq': ['$$i.toggled', "NULL"]},
                                                            {'$eq': ['$$i.toggled', "FALSE"]}
                                                        ]
                                                    },
                                            'then': False,
                                            'else': True
                                        }
                                    }
                                }
                            }
                        },
                        'shipping_info': 1,
                        'status': 1,
                        'org_id': 1,
                        'org_name': 1,
                        'autogenerated': 1
                    }
                }
            ]
            orders = await self.db.orders.aggregate(pipeline).to_list(length=None)
            if not orders:
                duration = datetime.now() - start
                print(f'Duration : {duration}')
                return []
            
            for order in orders:
                if "item" in order:
                    for item in order["item"]:
                        img_id = item["img_id"]
                        thumbnail_img_id = "t_" + img_id
                        if item["thumbnail"] == "null":
                            item["thumbnail"] = "null"
                        else:
                            item["thumbnail"] = generate_presigned_url(
                                thumbnail_img_id, "thumbnails-cart"
                            )
                        item["img_url"] = generate_presigned_url(
                            img_id, "browse-image-v2"
                        )
                        if item["toggled"] == 'true' or item['toggled'] == True or item['toggled'] == 'True':
                            item["toggled"] = generate_presigned_url(
                                "e_" + img_id, "browse-image-v2"
                            )

            duration = datetime.now() - start
            print(f'Duration : {duration}')
            return orders
        except Exception as e:
            logger.error(f"Error retrieving orders with user data: {e}")
            return []

    async def get_student_order(self, order_ids: list[str]) -> list:
        try:
            orders = await self.db.orders.find({'order_id': {'$in': order_ids}}).to_list(length=None)
            if not orders:
                return []

            user_ids = {order["user_id"] for order in orders}
            users = await self.db.users.find(
                {"user_id": {"$in": list(user_ids)}}
            ).to_list(length=None)
            user_dict = {
                user["user_id"]: user for user in users
            }  # Create a dictionary of users by user_id

            verfied_orders = []
            prevent_duplicate = 0
            for order in orders:
                if "status" in order and order["status"] == "verified" or order["status"] == "prepared":
                    fname=''
                    lname=''

                    user_data = user_dict.get(order["user_id"], {})
                    if 'first_name' in user_data and 'last_name' in user_data:
                        fname = user_data['first_name']
                        lname = user_data['last_name']
                    if 'shipping_info' in order and 'firstName' in order['shipping_info'] and 'lastName' in order['shipping_info']:
                        fname = order['shipping_info']['firstName']
                        lname = order['shipping_info']['lastName']

                    if fname == '' and lname == '':
                        continue

                    order["images"] = {}
                    if "item" in order:
                        for item in order["item"]:
                            greenmask = None
                            img_id = item["img_id"]
                            prevent_duplicate = prevent_duplicate + 1
                            if "greenmask" in item and item['greenmask'] != 'null' and  item['greenmask'] != '':
                                greenmask = item['greenmask']
                            
                            if "toggled" in item and (type(item["toggled"]) == bool and item["toggled"] != False) and (type(item["toggled"]) == str and item["toggled"] != 'False' and item["toggled"] != 'FALSE' and item["toggled"] != 'NULL'):
                                item["img_url"] = generate_presigned_url(
                                    item["toggled"], "browse-image-v2"
                                )
                            else:
                                item["img_url"] = generate_presigned_url(
                                    img_id, "browse-image-v2"
                                )
                            order["images"][
                                item["size"]
                                + "_"
                                + fname
                                + "_"
                                + lname
                                + "_"
                                + str(prevent_duplicate)
                            ] = {}
                            order["images"][
                                item["size"]
                                + "_"
                                + fname
                                + "_"
                                + lname
                                + "_"
                                + str(prevent_duplicate)
                            ]["img_path"] = item["img_url"]
                            order["images"][
                                item["size"]
                                + "_"
                                + fname
                                + "_"
                                + lname
                                + "_"
                                + str(prevent_duplicate)
                            ]["img_id"] = item["img_id"]
                            order["images"][
                                item["size"]
                                + "_"
                                + fname
                                + "_"
                                + lname
                                + "_"
                                + str(prevent_duplicate)
                            ]["greenmask"] = greenmask
                    verfied_orders.append(order)
            return verfied_orders
        except Exception as e:
            logger.error(f"Error retrieving orders with user data: {e}")
            return []

    async def get_userByEmail(self, user_email) -> list:
        try:
            user_data = await self.db.users.find_one({"email": user_email}, {"_id": 0})
            if user_data:
                return user_data
            else:
                return []
        except Exception as e:
            logger.error(f"Error retrieving orders with user data: {e}")
            return []

    async def create(self, user_id: str, order_info: OrderItem) -> bool:
        pass

    async def remove(self, user_id: str, order_info: OrderItem) -> bool:
        pass

    async def update(self, user_id: str, order_id: str, new_status: str):
        try:
            orders_update_result = await self.db.orders.update_one(
                {"order_id": order_id}, {"$set": {"status": new_status}}
            )

            if orders_update_result.modified_count > 0:
                logger.info(f"Order status updated successfully for order ID {order_id}")
                return True
            else:
                logger.warning(f"No changes made to the order status for order ID {order_id}")
                return False

        except Exception as e:
            logger.critical(f"Error in updating order status for user {user_id} with order ID {order_id}: {e}")
            return False
            
    async def bulk_update_orders(self, user_order_updates):
            try:
                order_updates = []
                for update in user_order_updates:
                    user_id = update["user_id"]
                    order_id = update["order_id"]
                    new_status = update["new_status"]

                    order_updates.append(
                        UpdateOne(
                            {"order_id": order_id},
                            {"$set": {"status": new_status}}
                        )
                    )
                orders_update_result = await self.db.orders.bulk_write(order_updates)
                if orders_update_result.modified_count > 0:
                    logger.info("Bulk order status update successful")
                    return True
                else:
                    logger.warning("No changes made during bulk order status update")
                    return False

            except Exception as e:
                logger.critical(f"Error in bulk updating order statuses: {e}")
                return False
            

    async def check_student_order(self, user_id: str):
        try:
            result = await self.db.users.find_one(
                {
                    "user_id": user_id,
                    "orders": {
                        "$elemMatch": {
                            "status": {
                                "$in": [
                                    "pending",
                                    "verified",
                                    "shipped",
                                    "delivering",
                                    "delivered",
                                ]
                            },
                        }
                    },
                }
            )
            if result:
                return True
            else:
                return False
        except Exception as e:
            logger.critical(f"Error checking student order status: {e}")
            return False

    async def update_order_status(self, user_id: str, order_id: str, new_status: str):
        try:
            orders_update_result = await self.db.orders.update_one(
                {"order_id": order_id},
                {"$set": {"status": new_status}},
            )
            return orders_update_result.modified_count > 0
        except Exception as e:
            logger.critical(f"Error updating order status: {e}")
            return False